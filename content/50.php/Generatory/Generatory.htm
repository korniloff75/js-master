<p>Столкнувшись с мнением специалистов о преимуществах использования генераторов перед обычными массивами, решил разобраться с этим вопросом. По мнению опытных программистов, итерирование массивов потребляет в разы больше ресурсов, чем итерирование генераторов. Когда я об этом услышав впервые, я сам с трудом понимал, что такое генераторы и с чем их едят. Поэтому начнем с понимания вопроса.</p>


<h2>Генераторы в PHP - что это такое?</h2>

<p>Генератор, по определению, является объектом, выдающим результаты своей деятельности. Такие результаты могут производиться (генерироваться) как единократно, так и с определённым интервалом. В PHP суть генератора есть функция. Такая функция, по своей конструкции, особенно не отличается от любой другой. Но среди её особенностей можно сразу выделить две: функция-генератор, в большинстве случаев, содержит в себе какой-либо из видов цикла, а также способна возвращать результат своей работы не единократно, как обычная (return), а многократно (yield).</p>
<p>Если быть более точным, то можно сказать, что функция-генератор возвращает объект, содержащий все результаты её работы, и обладающий интерфейсом <strong><a href="http://ua2.php.net/manual/ru/class.traversable.php" target="_blank" rel="nofollow">Traversable</a></strong>. А если проще - это объект-итератор. Подобные объекты способна обрабатывать внутренняя функция <b>foreach()</b>.</p>
<p>Во всем остальном генератор не отличим от функции. Он также может принимать аргументы и оперировать с ними, его также нужно инициализировать, etc.</p>

<h3>Пример генератора - ряд Фибоначчи</h3>

<p>В качестве примера простейшего генератора можно рассмотреть функцию, генерирующую математический ряд Фибоначчи, в котором первые два числа равны 0 и 1, а каждое последующее число равно сумме двух предыдущих. Поскольку сам ряд бесконечен, будем генерировать его первые 20 членов.</p>
<pre><code saldom=noLib>
	function xFibonachi () {
		$f=0; $s=1; $ss=0;
		yield $f;
		yield $s;
		for ($i=0; $i < 18; $i++) {
			$ss= $f + $s;
			$f= $s;
			$s= $ss;
			yield $ss;
		};
	}
</code></pre>
<p>Или сделаем его параметрическим, установив количество членов в качестве переменной</p>
<pre><code saldom=noLib>
	function xFibonachi ($c=20) {
		$f=0; $s=1; $ss=0;
		yield $f;
		yield $s;
		for ($c-=2; $c--;) {
			$ss= $f + $s;
			$f= $s;
			$s= $ss;
			yield $ss;
		};
	}
</code></pre>

<p>Итак, мы получили функцию-генератор. Как это проверить? Можно просто ввести команду <code>var_dump(xFibonachi ());</code>, в результате выполнения которой мы получим <code><?= var_dump(xFibonachi ()); ?></code>. То есть вызванная функция нам вернула объект. Не находите, что такое поведение очень сходно с поведением функций в <em>javascript</em>?</p>
<p>Как нам теперь использовать такой генератор? Если вы уже знакомы с итераторами (впоследствии напишу вводную статью и о них), то догадались, что результат работы такой функции можно обрабатывать в цикле.</p>
<p>Характерной особенностью такого использования является то, что цикл будет работать не с копией, как в случае использования массивов, а непосредственно с самим итератором, что значительно сокращает объем потребляемой памяти. В конце статьи я приведу пример-сравнение.</p>


<h3>Использование генератора</h3>

<p>Поскольку основные принципы работы я описал выше, привожу сам код подключения генератора и результаты его работы.</p>
<pre><code saldom=noLib>
	foreach(xFibonachi () as $d) {
		echo '<span style="margin: 0 1em 0;">'.$d.'</span>';
	}
</code></pre>

<h4>Результат работы</h4>

<?php
	function xFibonachi ($c=20) {
		$f=0; $s=1; $ss=0;
		yield $f;
		yield $s;
		for ($c-=2; $c--;) {
			$ss= $f + $s;
			$f= $s;
			$s= $ss;
//			echo '<span style="margin: 0 1em 0;">'.$ss.'</span>';
			yield $ss;
		};
	}


	echo '<div style="border:2px dotted red; display: flex; flex-wrap: wrap;">';
	foreach(xFibonachi (20) as $d) {
		echo '<span style="margin: 0 1em 0;">'.$d.'</span>';
	}
	echo '</div>';
?>

<p>Да, все настолько просто, что и не стоило длинных описаний. Или стоило? Напоминаю, приведенный пример является одним из самых примитивных. А если рассмотреть работу генератора в тандеме с итераторами, да при использовании с большими массивами данных... Но, признаюсь, я еще сам до этого не совсем дорос, но вижу довольно светлую перспективу.</p>


<h2>Сравнение массивов и генераторов</h2>

<p>Конечно, заголовок не корректен, но нужно коротко и понятно. Речь пойдет о сравнительном анализе потребляемых машинных ресурсов при обработке данных в классическом массиве и генераторе.</p>
<p>В качестве примера возьму тот же ряд Фибоначчи, но увеличу в нем количество обрабатываемых членов, скажем, до миллиона.</p>
<p>Версия используемой PHP - <strong><?= phpversion () ?></strong></p>



<h3>Обработка данных из массива</h3>

<pre><code saldom=noLib>
function Fibonachi ($c) {
	$f=0; $s=1; $ss=0; $arr=[];
	$arr[]= $f;
	$arr[]= $s;
	for ($c-=2; $c--;) {
		$ss= $f + $s;
		$f= $s;
		$s= $ss;
		$arr[]= $ss;
	}
	return $arr;
}
$start_time=microtime(true);

	$result = '';
	foreach(Fibonachi (1e6) as $d) {
		$result .= '<span style="margin: 0 1em 0;">'.$d.'</span>';
	}
$end_time=microtime(true);
echo "time: ", bcsub($end_time, $start_time, 4), "<br>";
echo "memory (MB): ", memory_get_peak_usage(true)/1024/1024, "<hr>";
</code></pre>

<?php
function Fibonachi ($c) {
	$f=0; $s=1; $ss=0; $arr=[];
	$arr[]= $f;
	$arr[]= $s;
	for ($c-=2; $c--;) {
		$ss= $f + $s;
		$f= $s;
		$s= $ss;
		$arr[]= $ss;
	}
//	echo '$arr - ' . count($arr);
	return $arr;
}
$start_time=microtime(true);

	$result = '';
	foreach(Fibonachi (1e6) as $d) {
		$result .= '<span style="margin: 0 1em 0;">'.$d.'</span>';
	}
$end_time=microtime(true);
echo "time: ", bcsub($end_time, $start_time, 4), "<br>";
echo "memory (MB): ", memory_get_peak_usage(true)/1024/1024, "<hr>";
?>


<h3>Обработка данных из генератора</h3>

<pre><code saldom=noLib>
$start_time=microtime(true);
	$result = '';
	foreach(xFibonachi (1e6) as $d) {
		$result .= '<span style="margin: 0 1em 0;">'.$d.'</span>';
	}
$end_time=microtime(true);
echo "time: ", bcsub($end_time, $start_time, 4), "<br>";
echo "memory (MB): ", memory_get_peak_usage(true)/1024/1024, "<hr>";
</code></pre>

<?php
$start_time=microtime(true);
	foreach(xFibonachi (1e6) as $d) {
		$result .= '<span style="margin: 0 1em 0;">'.$d.'</span>';
	}
$end_time=microtime(true);
echo "time: ", bcsub($end_time, $start_time, 4), "<br>";
echo "memory (MB): ", memory_get_peak_usage(true)/1024/1024, "<hr>";
?>


<h3>Сравнение результатов</h3>

<p>И вот тут, уважаемые господа, наступает ступор, у меня, во всяком случае. Это как??? Обработка массива показывает лучшие результаты, чем генератор?</p>
<p>Похоже, да. И всё дело в версии PHP. Сейчас, на момент написания, я тестирую на 7.1, на сервере хостинга у меня стоит 7.0 (посмотрим, что она еще покажет). Когда я переходил на семёрку, я, конечно читал о том, что основной задачей её выпуска было увеличение производительности, но не думал, что до такой степени.</p>


<h2>Выводы и заключение</h2>

<p>Все тезисы, представленные в статье, имеют место быть при использовании PHP ниже 7.0. В таких версиях генераторы позволяют уменьшить потребляемые ресурсы на порядок. В версиях 7+, как ни странно, выигрывает обработка массивов.</p>
<p>Тем не менее, не считаю, что зря написал эту статью. Ведь, во-первых, еще многие пользуются PHP-5, во вторых, всё же знакомство с генераторами состоялось, а в-третьих, я смог прийти к тем выводам, что пришел. Теперь каждый, кто хочет проверить скорость отработки данных из массива или генератора, может скопировать коды из этой статьи и тестировать их у себя.</p>
<p>Ну, а кто не склонен к экспериментаторству и любит использовать массивы, может вздохнуть спокойно. Создатели РНР-7 потрудились на славу и переходить на генераторы стало излишне.</p>
<p>Позже постараюсь потестировать работу генераторов в связке с итераторами, возможно, там будут другие результаты.</p>